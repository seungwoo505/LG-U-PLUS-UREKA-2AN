# 알고리즘

1) 정확성 : 얼마나 정확하게 동작하는가
2) 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
3) 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
4) 단순성 : 다른 사람이 이해하기 쉬운가
5) 최적성 : 더 이상 개선할 여지없이 최적화되었는가

    시간 복잡도     n의 가용 범위
    O(n!)           10
    O(2^n)          20~25
    O(n^3)          200~300
    O(n^2)          3000~5000
    O(nlogN)        100만
    O(n)            1000만~2000만
    O(logN)         10억


# 정렬

## 버블 정렬 (Bubble Sort)

- 인접한 두 개의 원소를 비교한 후 교환하는 과정을 반복하여 데이터를 정렬하는 방식
- 정렬 과정

	1> 첫 번째 원소부터 인접한 원소와 비교하여 자리를 교환해가면서 마지막 자리까지 이동한다

	2> 기준(오름차순)한 사이클이 끝나면 가장 큰 원소가 마지막 자리로 위치하게 된다

	3> 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다
- 시간복잡도 : O(n^2)   n이 5000이하일 때 사용하도록 하자

## 선택 정렬 (Selection Sort)

- 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
- 정렬 과정 (ex. 주어진 자료들 중 세 번째로 작은 값 찾기)

	1> 주어진 자료들 중 최소값을 찾는다
	2> 그 값을 리스트의 맨 앞에 위치한 값과 교환한다
	3> 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다
- 시간복잡도 : O(n^2)

## 삽입 정렬 (Insertion Sort)

- 정렬할　요소를　뒤에　있는　요소와　비교한　뒤　스왑이　일어났다면　앞에　있는　모든　요소와도　비교를　하는　방식
- 정렬 과정 
	1> 배열의　첫　번째　요소는　이미　정렬된　상태라고　가정
	2> 배열의　두　번째　요소（ｋｅｙ）부터　시작하여　앞　칸의　요소가　더　크면　스왑
	3> 이것을　맨　앞　요소까지 반복한다
	４＞　２～３번　반복
- 시간목잡도 : O(n^2)

## 카운팅 정렬 (Counting Sort)

－　요소가　몇　번씩　등장하는지　세는　방법으로　정렬하는　알고리즘
－　정렬방법
	１＞　원본　배열에서　요소가　몇번　등장하는지를　counting 배열이라는　새로운　배열에　저장한다．　이때　원본배열의　요소가　카운팅　배열의　인덱스가　되게　한다．
	２＞　카운팅　배열을　가지고　누적합을　계산한다．
	３＞　완성된　누적합　배열을　가지고　결과　배열을　생성한다．
－　시간복잡도　：　Ｏ（ｎ）

## 병합정렬 (Merge Sort)

－　분할　정복　알고리즘으로　정렬하는　방식
- 정렬 과정
	1> 원본　배열을　쪼갠다．최소　단위가　될 때까지　쪼갠다．
	2> 각　요소를　합하면서　비교하고　새 자리를　차지한다

- 시간복잡도 : O(ｎlogＮ)

## 퀵정렬 (Quick Sort)

－　분할　정복　알고리즘으로　정렬하는　방식
- 정렬 과정
	1>　피벗　선택： 배열에서　하나의　요소를　피벗（pivot）으로　선택한다．　보통　배열의　마지막　요소를　선택함．
	2> 파티션：　피벗을　기준으로　배열을　두　개의　부분으로　나눔．　피벗보다　작은　요소들은　왼쪽에，　큰　요소들은　오른쪽에　위치하도록　재배치　함．
	３＞　재귀　호출：　피벗의　위치가　정해지면，　피벗을　제외한　왼쪽과　오른쪽　부분　배열에　대해　재귀적으로　퀵　정렬을　수행
	４＞　종료조건：　배열의　크기가　１이　되면　정렬이　완료된　것으로　간주

- 시간복잡도 : 최악은　Ｏ（ｎ＾２）이지만　평균적으로　O(ｎlogＮ)이어서　빠른　알고리즘으로　간주됨

----------------------------------------------------------------------------------------------------------------------------------------------------------------

자바에서 가장 효율적인 정렬 API는 Arrays.sort()와 Collections.sort().

이 두 메서드는 Timsort 알고리즘(병합 정렬과 삽입 정렬의 하이브리드)을 기반으로 하며, 평균적으로 O(n log n)